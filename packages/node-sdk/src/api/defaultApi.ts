/**
 * Ctrlplane API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import http from "http";
import localVarRequest from "request";

/* tslint:disable:no-unused-locals */
import { AcknowledgeJob200Response } from "../model/acknowledgeJob200Response";
import { CreateEnvironment200Response } from "../model/createEnvironment200Response";
import { CreateEnvironment500Response } from "../model/createEnvironment500Response";
import { CreateEnvironmentRequest } from "../model/createEnvironmentRequest";
import { CreateRelease200Response } from "../model/createRelease200Response";
import { CreateReleaseRequest } from "../model/createReleaseRequest";
import { DeleteTarget200Response } from "../model/deleteTarget200Response";
import { GetAgentRunningJob200ResponseInner } from "../model/getAgentRunningJob200ResponseInner";
import { GetJob200Response } from "../model/getJob200Response";
import { GetNextJobs200Response } from "../model/getNextJobs200Response";
import { GetTarget200Response } from "../model/getTarget200Response";
import { GetTarget404Response } from "../model/getTarget404Response";
import { GetTargetByIdentifier200Response } from "../model/getTargetByIdentifier200Response";
import { GetTargetByIdentifier404Response } from "../model/getTargetByIdentifier404Response";
import {
  ApiKeyAuth,
  Authentication,
  HttpBasicAuth,
  HttpBearerAuth,
  Interceptor,
  OAuth,
  ObjectSerializer,
  VoidAuth,
} from "../model/models";
import { SetTargetProvidersTargetsRequest } from "../model/setTargetProvidersTargetsRequest";
import { UpdateJob200Response } from "../model/updateJob200Response";
import { UpdateJobAgent200Response } from "../model/updateJobAgent200Response";
import { UpdateJobAgentRequest } from "../model/updateJobAgentRequest";
import { UpdateJobRequest } from "../model/updateJobRequest";
import { UpdateTarget200Response } from "../model/updateTarget200Response";
import { UpdateTargetRequest } from "../model/updateTargetRequest";
import { UpsertTargetsRequest } from "../model/upsertTargetsRequest";
import { V1JobAgentsAgentIdQueueAcknowledgePost200Response } from "../model/v1JobAgentsAgentIdQueueAcknowledgePost200Response";
import { V1JobAgentsAgentIdQueueAcknowledgePost401Response } from "../model/v1JobAgentsAgentIdQueueAcknowledgePost401Response";
import { HttpError, RequestFile } from "./apis";

let defaultBasePath = "http://localhost";

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum DefaultApiApiKeys {
  apiKey,
}

export class DefaultApi {
  protected _basePath = defaultBasePath;
  protected _defaultHeaders: any = {};
  protected _useQuerystring: boolean = false;

  protected authentications = {
    default: <Authentication>new VoidAuth(),
    apiKey: new ApiKeyAuth("header", "x-api-key"),
  };

  protected interceptors: Interceptor[] = [];

  constructor(basePath?: string);
  constructor(
    basePathOrUsername: string,
    password?: string,
    basePath?: string,
  ) {
    if (password) {
      if (basePath) {
        this.basePath = basePath;
      }
    } else {
      if (basePathOrUsername) {
        this.basePath = basePathOrUsername;
      }
    }
  }

  set useQuerystring(value: boolean) {
    this._useQuerystring = value;
  }

  set basePath(basePath: string) {
    this._basePath = basePath;
  }

  set defaultHeaders(defaultHeaders: any) {
    this._defaultHeaders = defaultHeaders;
  }

  get defaultHeaders() {
    return this._defaultHeaders;
  }

  get basePath() {
    return this._basePath;
  }

  public setDefaultAuthentication(auth: Authentication) {
    this.authentications.default = auth;
  }

  public setApiKey(key: DefaultApiApiKeys, value: string) {
    (this.authentications as any)[DefaultApiApiKeys[key]].apiKey = value;
  }

  public addInterceptor(interceptor: Interceptor) {
    this.interceptors.push(interceptor);
  }

  /**
   *
   * @summary Acknowledge a job
   * @param jobId The job ID
   */
  public async acknowledgeJob(
    jobId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: AcknowledgeJob200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/v1/jobs/{jobId}/acknowledge".replace(
        "{" + "jobId" + "}",
        encodeURIComponent(String(jobId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'jobId' is not null or undefined
    if (jobId === null || jobId === undefined) {
      throw new Error(
        "Required parameter jobId was null or undefined when calling acknowledgeJob.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: AcknowledgeJob200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "AcknowledgeJob200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Create an environment
   * @param createEnvironmentRequest
   */
  public async createEnvironment(
    createEnvironmentRequest: CreateEnvironmentRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateEnvironment200Response;
  }> {
    const localVarPath = this.basePath + "/v1/environments";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createEnvironmentRequest' is not null or undefined
    if (
      createEnvironmentRequest === null ||
      createEnvironmentRequest === undefined
    ) {
      throw new Error(
        "Required parameter createEnvironmentRequest was null or undefined when calling createEnvironment.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createEnvironmentRequest,
        "CreateEnvironmentRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateEnvironment200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CreateEnvironment200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Creates a release
   * @param createReleaseRequest
   */
  public async createRelease(
    createReleaseRequest: CreateReleaseRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: CreateRelease200Response;
  }> {
    const localVarPath = this.basePath + "/v1/releases";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'createReleaseRequest' is not null or undefined
    if (createReleaseRequest === null || createReleaseRequest === undefined) {
      throw new Error(
        "Required parameter createReleaseRequest was null or undefined when calling createRelease.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        createReleaseRequest,
        "CreateReleaseRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: CreateRelease200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "CreateRelease200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Delete a target
   * @param targetId The target ID
   */
  public async deleteTarget(
    targetId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: DeleteTarget200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/v1/targets/{targetId}".replace(
        "{" + "targetId" + "}",
        encodeURIComponent(String(targetId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'targetId' is not null or undefined
    if (targetId === null || targetId === undefined) {
      throw new Error(
        "Required parameter targetId was null or undefined when calling deleteTarget.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "DELETE",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: DeleteTarget200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "DeleteTarget200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get a agents running jobs
   * @param agentId The execution ID
   */
  public async getAgentRunningJob(
    agentId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: Array<GetAgentRunningJob200ResponseInner>;
  }> {
    const localVarPath =
      this.basePath +
      "/v1/job-agents/{agentId}/jobs/running".replace(
        "{" + "agentId" + "}",
        encodeURIComponent(String(agentId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'agentId' is not null or undefined
    if (agentId === null || agentId === undefined) {
      throw new Error(
        "Required parameter agentId was null or undefined when calling getAgentRunningJob.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: Array<GetAgentRunningJob200ResponseInner>;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "Array<GetAgentRunningJob200ResponseInner>",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get a job
   * @param jobId The execution ID
   */
  public async getJob(
    jobId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: GetJob200Response }> {
    const localVarPath =
      this.basePath +
      "/v1/jobs/{jobId}".replace(
        "{" + "jobId" + "}",
        encodeURIComponent(String(jobId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'jobId' is not null or undefined
    if (jobId === null || jobId === undefined) {
      throw new Error(
        "Required parameter jobId was null or undefined when calling getJob.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetJob200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "GetJob200Response");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get the next jobs
   * @param agentId The agent ID
   */
  public async getNextJobs(
    agentId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: GetNextJobs200Response }> {
    const localVarPath =
      this.basePath +
      "/v1/job-agents/{agentId}/queue/next".replace(
        "{" + "agentId" + "}",
        encodeURIComponent(String(agentId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'agentId' is not null or undefined
    if (agentId === null || agentId === undefined) {
      throw new Error(
        "Required parameter agentId was null or undefined when calling getNextJobs.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetNextJobs200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "GetNextJobs200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get a target
   * @param targetId The target ID
   */
  public async getTarget(
    targetId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: GetTarget200Response }> {
    const localVarPath =
      this.basePath +
      "/v1/targets/{targetId}".replace(
        "{" + "targetId" + "}",
        encodeURIComponent(String(targetId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'targetId' is not null or undefined
    if (targetId === null || targetId === undefined) {
      throw new Error(
        "Required parameter targetId was null or undefined when calling getTarget.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTarget200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "GetTarget200Response");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Get a target by identifier
   * @param workspaceId ID of the workspace
   * @param identifier Identifier of the target
   */
  public async getTargetByIdentifier(
    workspaceId: string,
    identifier: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: GetTargetByIdentifier200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/v1/workspaces/{workspaceId}/targets/identifier/{identifier}"
        .replace(
          "{" + "workspaceId" + "}",
          encodeURIComponent(String(workspaceId)),
        )
        .replace(
          "{" + "identifier" + "}",
          encodeURIComponent(String(identifier)),
        );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        "Required parameter workspaceId was null or undefined when calling getTargetByIdentifier.",
      );
    }

    // verify required parameter 'identifier' is not null or undefined
    if (identifier === null || identifier === undefined) {
      throw new Error(
        "Required parameter identifier was null or undefined when calling getTargetByIdentifier.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: GetTargetByIdentifier200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "GetTargetByIdentifier200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Sets the target for a provider.
   * @param providerId UUID of the scanner
   * @param setTargetProvidersTargetsRequest
   */
  public async setTargetProvidersTargets(
    providerId: string,
    setTargetProvidersTargetsRequest: SetTargetProvidersTargetsRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath =
      this.basePath +
      "/v1/target-providers/{providerId}/set".replace(
        "{" + "providerId" + "}",
        encodeURIComponent(String(providerId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'providerId' is not null or undefined
    if (providerId === null || providerId === undefined) {
      throw new Error(
        "Required parameter providerId was null or undefined when calling setTargetProvidersTargets.",
      );
    }

    // verify required parameter 'setTargetProvidersTargetsRequest' is not null or undefined
    if (
      setTargetProvidersTargetsRequest === null ||
      setTargetProvidersTargetsRequest === undefined
    ) {
      throw new Error(
        "Required parameter setTargetProvidersTargetsRequest was null or undefined when calling setTargetProvidersTargets.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        setTargetProvidersTargetsRequest,
        "SetTargetProvidersTargetsRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body?: any }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        },
      );
    });
  }
  /**
   *
   * @summary Update a job
   * @param jobId The execution ID
   * @param updateJobRequest
   */
  public async updateJob(
    jobId: string,
    updateJobRequest: UpdateJobRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body: UpdateJob200Response }> {
    const localVarPath =
      this.basePath +
      "/v1/jobs/{jobId}".replace(
        "{" + "jobId" + "}",
        encodeURIComponent(String(jobId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'jobId' is not null or undefined
    if (jobId === null || jobId === undefined) {
      throw new Error(
        "Required parameter jobId was null or undefined when calling updateJob.",
      );
    }

    // verify required parameter 'updateJobRequest' is not null or undefined
    if (updateJobRequest === null || updateJobRequest === undefined) {
      throw new Error(
        "Required parameter updateJobRequest was null or undefined when calling updateJob.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(updateJobRequest, "UpdateJobRequest"),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateJob200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(body, "UpdateJob200Response");
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Upserts the agent
   * @param updateJobAgentRequest
   */
  public async updateJobAgent(
    updateJobAgentRequest: UpdateJobAgentRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateJobAgent200Response;
  }> {
    const localVarPath = this.basePath + "/v1/job-agents/name";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'updateJobAgentRequest' is not null or undefined
    if (updateJobAgentRequest === null || updateJobAgentRequest === undefined) {
      throw new Error(
        "Required parameter updateJobAgentRequest was null or undefined when calling updateJobAgent.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateJobAgentRequest,
        "UpdateJobAgentRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateJobAgent200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "UpdateJobAgent200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Update a target
   * @param targetId
   * @param updateTargetRequest
   */
  public async updateTarget(
    targetId: string,
    updateTargetRequest: UpdateTargetRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateTarget200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/v1/targets/{targetId}".replace(
        "{" + "targetId" + "}",
        encodeURIComponent(String(targetId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'targetId' is not null or undefined
    if (targetId === null || targetId === undefined) {
      throw new Error(
        "Required parameter targetId was null or undefined when calling updateTarget.",
      );
    }

    // verify required parameter 'updateTargetRequest' is not null or undefined
    if (updateTargetRequest === null || updateTargetRequest === undefined) {
      throw new Error(
        "Required parameter updateTargetRequest was null or undefined when calling updateTarget.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "PATCH",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        updateTargetRequest,
        "UpdateTargetRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateTarget200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "UpdateTarget200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Upserts a target provider.
   * @param workspaceId Name of the workspace
   * @param name Name of the target provider
   */
  public async upsertTargetProvider(
    workspaceId: string,
    name: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: UpdateJobAgent200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/v1/workspaces/{workspaceId}/target-providers/name/{name}"
        .replace(
          "{" + "workspaceId" + "}",
          encodeURIComponent(String(workspaceId)),
        )
        .replace("{" + "name" + "}", encodeURIComponent(String(name)));
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'workspaceId' is not null or undefined
    if (workspaceId === null || workspaceId === undefined) {
      throw new Error(
        "Required parameter workspaceId was null or undefined when calling upsertTargetProvider.",
      );
    }

    // verify required parameter 'name' is not null or undefined
    if (name === null || name === undefined) {
      throw new Error(
        "Required parameter name was null or undefined when calling upsertTargetProvider.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "GET",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: UpdateJobAgent200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "UpdateJobAgent200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
  /**
   *
   * @summary Create or update multiple targets
   * @param upsertTargetsRequest
   */
  public async upsertTargets(
    upsertTargetsRequest: UpsertTargetsRequest,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{ response: http.IncomingMessage; body?: any }> {
    const localVarPath = this.basePath + "/v1/targets";
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    let localVarFormParams: any = {};

    // verify required parameter 'upsertTargetsRequest' is not null or undefined
    if (upsertTargetsRequest === null || upsertTargetsRequest === undefined) {
      throw new Error(
        "Required parameter upsertTargetsRequest was null or undefined when calling upsertTargets.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
      body: ObjectSerializer.serialize(
        upsertTargetsRequest,
        "UpsertTargetsRequest",
      ),
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{ response: http.IncomingMessage; body?: any }>(
        (resolve, reject) => {
          localVarRequest(localVarRequestOptions, (error, response, body) => {
            if (error) {
              reject(error);
            } else {
              if (
                response.statusCode &&
                response.statusCode >= 200 &&
                response.statusCode <= 299
              ) {
                resolve({ response: response, body: body });
              } else {
                reject(new HttpError(response, body, response.statusCode));
              }
            }
          });
        },
      );
    });
  }
  /**
   *
   * @param agentId
   */
  public async v1JobAgentsAgentIdQueueAcknowledgePost(
    agentId: string,
    options: { headers: { [name: string]: string } } = { headers: {} },
  ): Promise<{
    response: http.IncomingMessage;
    body: V1JobAgentsAgentIdQueueAcknowledgePost200Response;
  }> {
    const localVarPath =
      this.basePath +
      "/v1/job-agents/{agentId}/queue/acknowledge".replace(
        "{" + "agentId" + "}",
        encodeURIComponent(String(agentId)),
      );
    let localVarQueryParameters: any = {};
    let localVarHeaderParams: any = (<any>Object).assign(
      {},
      this._defaultHeaders,
    );
    const produces = ["application/json"];
    // give precedence to 'application/json'
    if (produces.indexOf("application/json") >= 0) {
      localVarHeaderParams.Accept = "application/json";
    } else {
      localVarHeaderParams.Accept = produces.join(",");
    }
    let localVarFormParams: any = {};

    // verify required parameter 'agentId' is not null or undefined
    if (agentId === null || agentId === undefined) {
      throw new Error(
        "Required parameter agentId was null or undefined when calling v1JobAgentsAgentIdQueueAcknowledgePost.",
      );
    }

    (<any>Object).assign(localVarHeaderParams, options.headers);

    let localVarUseFormData = false;

    let localVarRequestOptions: localVarRequest.Options = {
      method: "POST",
      qs: localVarQueryParameters,
      headers: localVarHeaderParams,
      uri: localVarPath,
      useQuerystring: this._useQuerystring,
      json: true,
    };

    let authenticationPromise = Promise.resolve();
    authenticationPromise = authenticationPromise.then(() =>
      this.authentications.default.applyToRequest(localVarRequestOptions),
    );

    let interceptorPromise = authenticationPromise;
    for (const interceptor of this.interceptors) {
      interceptorPromise = interceptorPromise.then(() =>
        interceptor(localVarRequestOptions),
      );
    }

    return interceptorPromise.then(() => {
      if (Object.keys(localVarFormParams).length) {
        if (localVarUseFormData) {
          (<any>localVarRequestOptions).formData = localVarFormParams;
        } else {
          localVarRequestOptions.form = localVarFormParams;
        }
      }
      return new Promise<{
        response: http.IncomingMessage;
        body: V1JobAgentsAgentIdQueueAcknowledgePost200Response;
      }>((resolve, reject) => {
        localVarRequest(localVarRequestOptions, (error, response, body) => {
          if (error) {
            reject(error);
          } else {
            if (
              response.statusCode &&
              response.statusCode >= 200 &&
              response.statusCode <= 299
            ) {
              body = ObjectSerializer.deserialize(
                body,
                "V1JobAgentsAgentIdQueueAcknowledgePost200Response",
              );
              resolve({ response: response, body: body });
            } else {
              reject(new HttpError(response, body, response.statusCode));
            }
          }
        });
      });
    });
  }
}
